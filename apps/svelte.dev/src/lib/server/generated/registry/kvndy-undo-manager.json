{
	"name": "@kvndy/undo-manager",
	"description": "Manage undo/redo functionality for Svelte stores.",
	"repo_url": "https://gitlab.com/kevindoughty/undo-manager",
	"authors": ["kvndy"],
	"homepage": "https://gitlab.com/kevindoughty/undo-manager#readme",
	"downloads": 19,
	"updated": "2025-01-10T21:12:18.933Z",
	"tags": ["miscellaneous"],
	"typescript": true,
	"version": "6.2.0",
	"svelte_range": "^5.17.3",
	"last_rune_check_version": "6.2.0",
	"dependency_tree": {
		"rootIndex": 0,
		"packages": [
			{
				"name": "@kvndy/undo-manager",
				"version": "6.2.0",
				"size": 270818
			},
			{
				"name": "@preact/signals",
				"version": "2.0.4",
				"size": 143864
			},
			{
				"name": "@preact/signals-core",
				"version": "1.8.0",
				"size": 183979
			}
		],
		"dependencies": [
			[0, 1],
			[1, 2]
		],
		"circular": []
	},
	"readme": "# UndoManager\n\nThis package provides undo and redo management for Preact and Solid Signals, Preact Signals for React, Svelte Stores, Vue Shallow Refs, and React Hooks. Its innovation is in having effectively two separate data models. Changes to one class, the Undoable, automatically register with an undo stack. Changes to a second class, the Preservable, do not themselves result in a new addition to the undo stack, but as their name would suggest are preserved when a change to an Undoable is made.\n\nUndoables are meant to provide navigation of user data through history in a document-based architecture for web-based apps. Preservables are meant to restore presentational state and visual appearance. In other words, they take the user to where they were when they made the change. The canonical example is preserving expanded/collapsed state of a tree view with disclosure triangles.\n\nAn aspect of Preservables which may not be immediately intuitive is their value as restored by navigating the undo stack depends on the direction traveled. The value of a Preservable when reaching a certain state of an Undoable via undo may be different when reaching the very same state of an Undoable via redo. This is accomplished by capturing the value of all Preservables both before and after a change to an Undoable.\n\nWhen undoing, the user typically wants appearances to be as they were right before they made a change. When redoing, the user typically wants appearances to be as they were right after a change. Without this behavior it would be impossible to see the location of any changes made because navigation would take them somewhere else every time.\n\nIf two consecutive undos drastically change the layout of an app making a change difficult to spot, when immediately followed by a redo appearances would align with user expectation. Toggling undo state back and forth to attract the eye to the location of change naturally occurs to the user, and is an inherent feature which does not need to be documented.\n\n## Installation\n\n```sh\nnpm install @kvndy/undo-manager\n```\n\n## API\n\n```js\n//import { UndoManager } from \"@kvndy/undo-manager\"; // legacy\nimport { UndoManager } from \"@kvndy/undo-manager/preact-signals\"; // Javascript\n//import { UndoManager, type Undoable, type Preservable, type Localizer } from \"@kvndy/undo-manager/preact-signals\"; // Typescript\n//const { UndoManager, type Undoable, type Preservable, type Localizer } = require(\"@kvndy/undo-manager/preact-signals\"); // Node\n//import { UndoManager, type Undoable, type Preservable, type Localizer } from \"@kvndy/undo-manager/svelte-stores\"; // Svelte\n//import { UndoManager, type Undoable, type Preservable, type Localizer } from \"@kvndy/undo-manager/solid-signals\"; // Solid\n//import { UndoManager, type Undoable, type Preservable, type Localizer } from \"@kvndy/undo-manager/vue-shallow-refs\"; // Vue\n//import { UndoManager, type Undoable, type Preservable, type Localizer } from \"@kvndy/undo-manager/preact-signals-react\"; // React Signals\n//import { UndoManager, type Undoable, type Preservable, type Localizer } from \"@kvndy/undo-manager/react-hooks\"; // React Hooks\n```\n\nThe single export is the `UndoManager` object constructor which exposes primitives to be used for managing the undo stack.\n\n### `new UndoManager(undoLocalizer, redoLocalizer, maxCount)`\n\nCreates a new `UndoManager` object for managing an undo stack. Its first two parameters are both optional functions meant to generate strings to be used as tooltips or menu items describing what specific change an undo or redo would produce. Each function is in turn passed a single argument of the developer’s choosing.\n\n`undoLocalizer` is a function that generates the `undoDescription` for a given change to an `Undoable`. It has one parameter, the `description` from an `Undoable` or `group`, and should return a string or `null`.\n\n`redoLocalizer` is a function that generates the `redoDescription` for a given change to an `Undoable`. It has one parameter, the `description` from an `Undoable` or `group`, and should return a string or `null`.\n\n`maxCount` is a positive integer that determines the size of the undo stack. The default is `Infinity`.\n\n\n\n```js\nconst undoLocalizer = (description) => {\n\treturn \"Undo \" + description;\n}\nconst redoLocalizer = (description) => {\n\treturn \"Redo \" + description;\n}\nconst { undoable, preservable, group, undo, redo, canUndo, canRedo, undoDescription, redoDescription } = new UndoManager(undoLocalizer, redoLocalizer);\n```\n\n### `undoable(value, description, coalescing)`\n\nCreates an Undoable object which is meant to be used in place of a Signal. It privately maintains a Signal to hold its value and provide timely UI updates. It exposes a similar API as a Signal, with `value` getter and setter accessors.\n\n`value` is passed along to its Signal upon creation.\n\n`description` is an optional object which is passed to the `undoLocalizer` and `redoLocalizer` functions to generate an `undoDescription` and `redoDescription`. Pass `null` or `undefined` to bypass for no description. There is an alternative method for more dynamic descriptions using `group`. \n\n`coalescing` is an optional object with a default value of `false` but is not limited to booleans. When `true`, multiple successive changes to an Undoable only register as a single change. When an object, referential equality determines if changes can also coalesce with a `group` using the same object.\n\n```js\nconst setting = undoable(0, \"change setting\", true);\nsetting.value = 1; // registers for undo\n```\n\n### `preservable(value, interrupting)`\n\nCreates a Preservable object which is also meant to be used in place of a Signal, privately maintains one of its own, and exposes a similar API as a Signal through `value` getter and setter accessors.\n\n`value` is passed along to its Signal upon creation.\n\n`interrupting` is an optional `boolean` that specifies if changes inhibit coalescing when not called from within an enclosing `group`.\n\n```js\nconst appearance = preservable(0, true);\nappearance.value = 2; // does not register for undo\nsetting.value = 3; // previous appearance value of 2 is captured as both its before state and after state\nappearance.value = 4; // not captured as the after state of the previous change to setting\n```\n\n### `group(callback, description, coalescing)`\n\nMakes use of the Signals `batch` function which permits multiple signal writes into one update. A change to a `Preservable` is considered made after any change to an `Undoable` regardless of call order. The `description` and `coalescing` key from the outer `group` are used. \n\n`callback` is the function which gets passed to a Signals `batch` call.\n\n`description` is an optional object similar to the second parameter of `undoable` and is not limited to strings. The `undoLocalizer` or `redoLocalizer` functions can be written to handle an array or other object for more precise and dynamic descriptions of a change. Pass `null` or `undefined` to bypass for no description.\n\n`coalescing` is an optional object similar to the third parameter of `undoable` and is not limited to booleans. If `true`, the `description` is used as a unique key to determine if changes should be coalesced. Otherwise if the argument is not `null`, `undefined`, or `false` it is used as the unique key.\n\n```js\ngroup( () => {\n\tsetting.value = 5; // registers for undo\n\tappearance.value = 6; // properly registers as the after change value\n}, \"change setting and more\", true); // does not coalesce with previous change\ngroup( () => {\n\tsetting.value = 7; // registers for undo\n\tappearance.value = 8; // properly registers as the after change value\n}, \"change setting and more\", true); // does coalesce with previous change\n```\n\nIt is a commonly held belief that parameters should not come after a function, but rather before for readability. Not adhering to this was a concious choice as the second and third parameter are optional.\n\n### `undo()`\n\nNavigates to the previous state.\n\n```js\nundo();\nassert.equal(setting.value, 3); // both grouped changes were coalesced and now undone\nassert.equal(appearance.value, 4); // this was the value before those changes were made\nundo();\nassert.equal(setting.value, 1);\nassert.equal(appearance.value, 2);\n```\n\nCalling `undo` within a `group` will silently fail.\n\n### `redo()`\n\nNavigates to the next state.\n\n```js\nredo();\nassert.equal(setting.value, 3); // arriving at same value from a different direction\nassert.equal(appearance.value, 2); // as commented above, value did not change\n```\n\nCalling `redo` within a `group` will silently fail.\n\n### `canUndo`\n\nA Signals `computed` whose `value` getter returns a boolean that provides if undo is possible.\n\n```js\nassert.equal(canUndo.value, true);\n```\n\n### `canRedo`\n\nA Signals `computed` whose `value` getter returns a boolean that provides if redo is possible.\n\n```js\nassert.equal(canRedo.value, true);\n```\n\n### `undoDescription`\n\nA Signals `computed` whose `value` getter returns the result of the `undoLocalizer` function passed to the `UndoManager` constructor.\n\n```js\nassert.equal(undoDescription.value, \"Undo change setting\");\n```\n\n### `redoDescription`\n\nA Signals `computed` whose `value` getter returns the result of the `redoLocalizer` function passed to the `UndoManager` constructor.\n\n```js\nassert.equal(redoDescription.value, \"Redo change setting and more\");\n```\n\n## Conceptual\n\nFor anything other than the simplest of use cases, all changes should be wrapped in a group. Consistency avoids confusion that may arise due to an overly generous optional API.\n\nIt is possible to create undoables and preservables after changes are underway to the undo stack. This is not considered best practice. Their value in the undo stack prior to their creation will be represented as their initial value.\n\n```js\nconst dont = undoable(\"just\"); // just don't\ndont.value = \"dont\";\nundo();\nundo();// before it existed\nassert(dont.value, \"just\");\nredo();\nredo();\n```\n\n### `coalescing`\n\nFor the strictest use, the `coalescing` parameter of `undoable` and `group` should only ever be passed a Symbol. It can be thought of as a coalescing key. Passing a boolean or string is for developer convenience and perfectly fine however. Its intended use is for but not limited to changes made by continuous dragging events.\n\nCoalescing does not overwrite any captured preservable before values. Changing a preservable inside a group set to coalesce will not register as a before value even if there is no change to an undoable. It will be captured as an after value, regardless of interrupting behavior or any coalesced changes to an undoable that may follow after its group.\n\nNavigating the undo stack via `undo` and `redo` will interrupt and prevent coalescing. Changes to preservables without a change to an undoable are lost on undo.\n\n```js\ngroup( () => {\n\tappearance.value = 9; // will be registered as the after change value \n}, \"conceptual section changes\", true);\ngroup( () => {\n\tsetting.value = 7; \n}, \"conceptual section changes\", true); // coalesces\nundo();\nassert.equal(appearance.value, 2); // coalescing group did not affect before value\nredo();\nassert.equal(appearance.value, 9);\n```\n\n```js\ngroup( () => {\n\tappearance.value = 10;\n}, \"conceptual section changes\", true); // does not coalesce\nassert.equal(appearance.value, 10);\nundo();\nredo();\nassert.equal(appearance.value, 9); // changes are lost\n```\n\n### `interrupting`\n\nIf preservable changes are always wrapped in a group, the `interrupting` parameter of `preservable` can be ignored and omitted. If no changes are ever coalesced it can also be ignored and omitted. Only if both of these two conditions are not met does the author need to decide if changing preservable state should affect coalescing. Pass `true` to prevent coalescing or `false` to permit coalescing.\n\n## Implementations\n\n### Preact Signals\n\nThe `value` accessor must always be used, unlike Preact Signals which have an optimization for fine-grained reactivity which allow it to be omitted inside html components.\n\n[Typescript definitions](https://gitlab.com/kevindoughty/undo-manager/-/blob/master/preact-signals/source/types.ts)\n\n[Sample code](https://gitlab.com/kevindoughty/undo-manager/-/blob/master/examples/preact-signals/src/index.tsx)\n\n### Preact Signals for React\n\nCurrently, only the `useSignals` hook imported from `@preact/signals-react/runtime` is supported. Use with `@preact/signals-react-transform` has not been shown to work.\n\nThe return value types of `Localizer` are `string` or `undefined`, unlike every other package which return `string` or `null`.\n\nLike Preact Signals for Preact, the `value` accessor must be used.\n\n[Typescript definitions](https://gitlab.com/kevindoughty/undo-manager/-/blob/master/preact-signals-react/source/types.ts)\n\n[Sample code](https://gitlab.com/kevindoughty/undo-manager/-/blob/master/examples/preact-signals-react/src/App.tsx)\n\n### Svelte Stores\n\nUndoables and preservables are created in the same way as Svelte’s `writable` stores. They pass messages to a private store instance through the public API.\n\nThe `get`, `set`, `update` and `$` accessors of Svelte Stores, along with `subscribe`, `unsubscribe`, and `derived`, work in place of the Preact Signals syntax shown above.\n\n[Typescript definitions](https://gitlab.com/kevindoughty/undo-manager/-/blob/master/svelte-stores/source/types.ts)\n\n[Sample code](https://gitlab.com/kevindoughty/undo-manager/-/blob/master/examples/svelte-stores/src/App.svelte)\n\n### Solid Signals\n\nUndoables and preservables are created in the same way as Solid’s `createSignal`. They support the standard behavior of destructuring the getter and setter from the return value, which are to be used in place of the Preact Signals syntax shown above.\n\nUndoables and preservables take an additional parameter for SignalOptions which gets passed to their private signal. Its `equals` function is used by undo-manager for comparison.\n\nThe setter types currently supported are passing a value and passing an update function. The value may be undefined, including a setter with no passed arguments.\n\nThe `update` function setter must be pure and without side effects, as it is used internally by both undo-manager and Solid, resulting in being called more than once.\n\n[Typescript definitions](https://gitlab.com/kevindoughty/undo-manager/-/blob/master/solid-signals/source/types.ts)\n\n[Sample code](https://gitlab.com/kevindoughty/undo-manager/-/blob/master/examples/solid-signals/src/App.jsx)\n\n### Vue Shallow Refs\n\nUsage is mostly the same as with Preact Signals. Unlike shallow refs, the value accessor must be included when contained inside double curly braces. However, the value accessor must be excluded from text inside element attribute binding strings.\n\nBehavior only differs with the absence of a batch function, which can affect the output of effects if they get called more than once.\n\n[Typescript definitions](https://gitlab.com/kevindoughty/undo-manager/-/blob/master/vue-shallow-refs/source/types.ts)\n\n[Sample code](https://gitlab.com/kevindoughty/undo-manager/-/blob/master/examples/vue-shallow-refs/src/App.vue)\n\n\n### React Hooks\n\nThe exposed API of the `UndoManager` constructor varies from other implementations to conform with naming conventions for Hooks.\n```\nconst { useUndoable, usePreservable, useCanUndo, useCanRedo, useUndoDescription, useRedoDescription, group, undo, redo } = new UndoManager(undoLocalizer, redoLocalizer);\n```\n\n`useUndoable` and `usePreservable` return an array with a value in the first position and a setter in the second. As with most hooks, these would typically be destructured.\n\nThe `description` second parameter to `useUndoable` is required and used as a unique key to differentiate between hooks. This value is also passed as the `description` parameter to `Localizer` functions to generate undo and redo descriptions. As in other implementations, the `description` second parameter to `group` overrides a `description` of an undoable. The `description` second parameter to `group` does not override the use as a unique key.\n\nThe method signature of `usePreservable` differs from other implementations in that it has the same second parameter `description` which is required and used as a unique key, like its `useUndoable` counterpart. This description is not used for any other purpose. The `interrupting` boolean follows in the third position.\n\nThere are currently no signficant tests to verify behavior. It should be noted that the code between various implementations does not vary significantly except in library-specific usage.\n\nThis implementation uses internally the hook `useSyncExternalStore`. It gets passed as a third argument the same `getSnapshot` function passed to the second, but its behavior when used on the backend is undefined.\n\n[Typescript definitions](https://gitlab.com/kevindoughty/undo-manager/-/blob/master/react-hooks/source/types.ts)\n\n[Sample code](https://gitlab.com/kevindoughty/undo-manager/-/blob/master/examples/react-hooks/src/App.tsx)\n\n\n## Example\n\nTrivial examples for every supported configuration are included in the repo.\n\nA non-virtual, non-animated tree view that preserves selection and expanded/collapsed state, for Preact:\n[https://gitlab.com/kevindoughty/cute-tree](https://gitlab.com/kevindoughty/cute-tree)\n\nLive demo:\n[https://kevindoughty.gitlab.io/cute-tree/index.html](https://kevindoughty.gitlab.io/cute-tree/index.html)\n\nThis project uses a technique first developed for Objective-C:\n[https://github.com/kevindoughty/cletustheslackjawedoutlineview](https://github.com/kevindoughty/cletustheslackjawedoutlineview).\n\n## Changelog\n\n### Version 6:\n* Type of return value for `undoDescription` and `redoDescription` changed from `<string | null>` to `<string | undefined>`.\n* Type of parameter `description` for type `Localizer` changed from `unknown` to `any`.\n* Type of parameter `description` for `undoable` changed from `unknown` to `any`.\n* Type of parameter `description` for `group` changed from `unknown` to `any`.\n\n## License\n\nMIT\n\n## Issues and PRs\n\nWelcome, especially for tooling and bundling, Typescript types and JSDoc definitions, tests for React Hooks, and API and implementation suggestions for Svelte Runes, Solid Stores, Vue Reactivity, and non-shallow Vue Refs.",
	"legacy_svelte": false,
	"downloads_history": [
		[3589, 12],
		[3596, 3],
		[3603, 3],
		[3610, 4],
		[3617, 2],
		[3624, 5],
		[3631, 5],
		[3638, 2],
		[3659, 4],
		[3666, 6],
		[3673, 1],
		[3680, 2],
		[3687, 1],
		[3694, 2],
		[3708, 2],
		[3715, 2],
		[3722, 1],
		[3729, 3],
		[3736, 1],
		[3743, 356],
		[3750, 77],
		[3757, 12],
		[3764, 3],
		[3771, 3],
		[3778, 61],
		[3785, 14],
		[3792, 62],
		[3799, 6],
		[3806, 7],
		[3813, 5],
		[3820, 4],
		[3827, 2],
		[3834, 31],
		[3841, 33],
		[3848, 3],
		[3855, 1],
		[3862, 28],
		[3869, 2],
		[3876, 3],
		[3883, 98],
		[3890, 561],
		[3897, 634],
		[3904, 92],
		[3911, 257],
		[3918, 308],
		[3925, 18],
		[3932, 21],
		[3939, 46],
		[3946, 3],
		[3953, 3],
		[3960, 7],
		[3967, 4],
		[3974, 1],
		[3981, 1],
		[3988, 2],
		[3995, 13],
		[4002, 54],
		[4009, 13],
		[4016, 10],
		[4023, 151],
		[4030, 36],
		[4037, 8],
		[4044, 36],
		[4051, 23],
		[4058, 3],
		[4065, 49],
		[4072, 3],
		[4079, 1],
		[4086, 1],
		[4100, 48],
		[4107, 51],
		[4114, 19],
		[4121, 20],
		[4128, 7]
	],
	"esm": true,
	"cjs": true
}
